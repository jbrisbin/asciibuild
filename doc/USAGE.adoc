= Using `asciibuild`

To use `asciibuild` on your Asciidoctor files, make sure you add the require flag to your invocation of `asciidoctor` or just use the `asciibuild` executable that was insalled with the gem:

----
> asciibuild build.adoc
----

In a stock Asciidoctor file, this won't do anything other process your `.adoc` into your preferred backend (`html` by default). If you want `asciibuild` to EVAL your listing blocks, just add a style to your listing blocks of `[asciibuild,{lang}]`.

== Using Shell

To use a `bash` or `sh` shell, add the `[asciibuild,bash]` or `[asciibuild,sh]` style to any listing block.

[listing]
[source,asciidoc]
....
.Execute BASH in asciibuild
[source,bash]
[asciibuild,bash]
----
echo Hello `uname -s`
----
....

== Using asciibuild as Spark Notebook

`asciibuild` supports http://spark.apache.org/[Apache Spark] out-of-the-box. It supports both http://spark.apache.org/docs/latest/programming-guide.html#tab_python_0[pyspark] and http://spark.apache.org/docs/latest/programming-guide.html#tab_scala_0[spark-shell] (Python and Scala, respectively). To use the Spark support in `asciibuild`, add a style of `[asciibuild,pyspark]` for PySpark or `[asciibuild,spark-shell]` for Scala.

This example is taken from the Spark documentation on using Python with Spark:

[listing]
[source,asciidoc]
....
.Execute PySpark in asciibuild
[source,python]
[asciibuild,pyspark]
----
from pyspark import SparkContext

logFile = "README.adoc"
sc = SparkContext("local", "Simple App")
logData = sc.textFile(logFile).cache()

numAs = logData.filter(lambda s: 'a' in s).count()
numBs = logData.filter(lambda s: 'b' in s).count()

print("Lines with a: %i, lines with b: %i" % (numAs, numBs))
----
....

== Using other Languages

`asciibuild` will support any language who's executable accepts `<STDIN>` as input. If you can pipe content into it, you can use it in `asciibuild`. Here's an example using Python:

[listing]
[source,asciidoc]
....
.Execute Python in asciibuild
[source,python]
[asciibuild,python]
----
import subprocess
print "OS:"
subprocess.call(["uname", "-s"])
----
....

NOTE: The styles `[source,bash]` and `[source,python]` are for the benefit of editors that recognize Asciidoc and will show source code formatting in a preview. `asciibuild` will add its own styles to the resulting blocks, regardless of what is set in the source document, so the generated document will be formatted correctly.
